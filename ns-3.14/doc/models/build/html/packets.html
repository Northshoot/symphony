

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Packets &mdash; Model Library</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     'ns-3-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Model Library" href="index.html" />
    <link rel="up" title="Network Module" href="network.html" />
    <link rel="next" title="Node and NetDevices Overview" href="network-overview.html" />
    <link rel="prev" title="Network Module" href="network.html" />
  <link rel="stylesheet" type="text/css"
    href="_static/ns3_stylesheet.css" />
    <link rel="icon" type="image/ico" 
      href="_static/favicon.ico" />

  <script type="text/javascript" src="_static/drop-down-menu.js"></script>
  <script type="text/javascript" src="_static/ns3_version.js"></script>
  <script type="text/javascript">var ns3_builder="html";</script>
  <script type="text/javascript" src="_static/ns3_links.js"></script>
      

  </head>
  <body>
  <div id="titlearea">
    <table cellspacing="0" cellpadding="0" width="100%">
      <tbody>
	<tr style="height: 56px;">
	  <td id="projectlogo">
	    <a id="ns3_home1"
	       href="http://www.nsnam.org/">
	       <img alt="ns-3 Logo"
		    src="_static/ns-3-inverted-notext-small.png"/>
	    </a>
	  </td>
	  <td id="projecttext">
	    <div id="projectbrief">A Discrete-Event Network Simulator</div>
	      <span id="projectnumber"><script type="text/javascript">document.write(ns3_version)</script></span>
	  </td>
	      
	  <td id="ns3-menu">
	    <div class="menu">
	      <ul >
	        <li><a id="ns3_home2"
		       href="http://www.nsnam.org/"
		       >&nbsp;&nbsp;Home</a>
	        </li>
	        <li><span
		      onmouseover="mopen('mTuts')" 
		      onmouseout="mclosetime()"
			>Tutorials &nbsp;&#x25BC;</span>
		    <div id="mTuts" 
		        onmouseover="mcancelclosetime()" 
		        onmouseout="mclosetime()">
		      <a id="ns3_tut"
			 href="/docs/tutorial/html/index.html"
			  >English</a><br/>
		      <a id="ns3_ptbr"
			 href="/docs/tutorial-pt-br/html/index.html"
			    >Portuguese</a><br/>
	        </li>
	        <li><span
		      onmouseover="mopen('mDocs')" 
		      onmouseout="mclosetime()"
			>Docs &nbsp;&nbsp;&nbsp;&#x25BC;</span>
		    <div id="mDocs"
		        onmouseover="mcancelclosetime()" 
		        onmouseout="mclosetime()">
		      <a id="ns3_wiki"
			 href="http://www.nsnam.org/wiki"
			 >Wiki</a><br/>
		      <a id="ns3_man"
			 href="/docs/manual/html/index.html"
			 >Manual</a><br/>
		      <a id="ns3_mod"
			 href="/docs/models/html/index.html"
			 >Models</a><br/>
	        </li>
	        <li><span
		      onmouseover="mopen('mDev')" 
		      onmouseout="mclosetime()"
			>Develop &#x25BC;</span>
		    <div id="mDev"
		        onmouseover="mcancelclosetime()" 
		        onmouseout="mclosetime()">
		      <a id="ns3_api"
			 href="/docs/doxygen/html/index.html"
			 >API</a><br/>
		      <a id="ns3_bugs"
		       href="http://www.nsnam.org/bugzilla/">Bugs</a>
	        </li>
	      </ul>
	    </div>
	  </td>
	  <td id="projectsection">
	    <span style="margin-right:10px">Models</span>
	  </td>
	</tr>
      </tbody>
    </table>
    <script  type="text/javascript">ns3_write_links()</script>
  </div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="network-overview.html" title="Node and NetDevices Overview"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="network.html" title="Network Module"
             accesskey="P">previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li><a href="network.html" accesskey="U">Network Module</a><span class="navelem">&nbsp;</span></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="packets">
<h1>Packets<a class="headerlink" href="#packets" title="Permalink to this headline">¶</a></h1>
<p>The design of the Packet framework of <em>ns</em> was heavily guided by a few
important use-cases:</p>
<ul class="simple">
<li>avoid changing the core of the simulator to introduce new types of packet
headers or trailers</li>
<li>maximize the ease of integration with real-world code and systems</li>
<li>make it easy to support fragmentation, defragmentation, and, concatenation
which are important, especially in wireless systems.</li>
<li>make memory management of this object efficient</li>
<li>allow actual application data or dummy application bytes for emulated
applications</li>
</ul>
<p>Each network packet contains a byte buffer, a set of byte tags, a set of packet
tags, and metadata.</p>
<p>The byte buffer stores the serialized content of the headers and trailers added
to a packet. The serialized representation of these headers is expected to match
that of real network packets bit for bit (although nothing forces you to do
this) which means that the content of a packet buffer is expected to be that of
a real packet.</p>
<p>Fragmentation and defragmentation are quite natural to implement within this
context: since we have a buffer of real bytes, we can split it in multiple
fragments and re-assemble these fragments. We expect that this choice will make
it really easy to wrap our Packet data structure within Linux-style skb or
BSD-style mbuf to integrate real-world kernel code in the simulator. We also
expect that performing a real-time plug of the simulator to a real-world network
will be easy.</p>
<p>One problem that this design choice raises is that it is difficult to
pretty-print the packet headers without context. The packet metadata describes
the type of the headers and trailers which were serialized in the byte buffer.
The maintenance of metadata is optional and disabled by default. To enable it,
you must call Packet::EnableMetadata() and this will allow you to get non-empty
output from Packet::Print and Packet::Print.</p>
<p>Also, developers often want to store data in packet objects that is not found
in the real packets (such as timestamps or flow-ids). The Packet class
deals with this requirement by storing a set of tags (class Tag).
We have found two classes of use cases for these tags, which leads to
two different types of tags. So-called &#8216;byte&#8217; tags are used to tag a subset of
the bytes in the packet byte buffer while &#8216;packet&#8217; tags are used to tag the
packet itself. The main difference between these two kinds of tags is what
happens when packets are copied, fragmented, and reassembled: &#8216;byte&#8217; tags follow
bytes while &#8216;packet&#8217; tags follow packets. Another important difference between
these two kinds of tags is that byte tags cannot be removed and are expected to
be written once, and read many times, while packet tags are expected to be
written once, read many times, and removed exactly once. An example of a &#8216;byte&#8217;
tag is a FlowIdTag which contains a flow id and is set by the application
generating traffic. An example of a &#8216;packet&#8217; tag is a cross-layer QoS class id
set by an application and processed by a lower-level MAC layer.</p>
<p>Memory management of Packet objects is entirely automatic and extremely
efficient: memory for the application-level payload can be modeled by a virtual
buffer of zero-filled bytes for which memory is never allocated unless
explicitly requested by the user or unless the packet is fragmented or
serialized out to a real network device. Furthermore, copying, adding, and,
removing headers or trailers to a packet has been optimized to be virtually free
through a technique known as Copy On Write.</p>
<p>Packets (messages) are fundamental objects in the simulator and
their design is important from a performance and resource management
perspective. There are various ways to design the simulation packet, and
tradeoffs among the different approaches. In particular, there is a tension
between ease-of-use, performance, and safe interface design.</p>
<div class="section" id="packet-design-overview">
<h2>Packet design overview<a class="headerlink" href="#packet-design-overview" title="Permalink to this headline">¶</a></h2>
<p>Unlike <em>ns-2</em>, in which Packet objects contain a buffer of C++
structures corresponding to protocol headers, each network packet in
<em>ns-3</em> contains a byte Buffer, a list of byte Tags, a list of
packet Tags, and a PacketMetadata object:</p>
<ul class="simple">
<li>The byte buffer stores the serialized content of the chunks added to a packet.
The serialized representation of these chunks is expected to match that of
real network packets bit for bit (although nothing forces you to do this)
which means that the content of a packet buffer is expected to be that of a
real packet.  Packets can also be created with an arbitrary zero-filled
payload for which no real memory is allocated.</li>
<li>Each list of tags stores an arbitrarily large set of arbitrary user-provided
data structures in the packet.  Each Tag is uniquely identified by its type;
only one instance of each type of data structure is allowed in a list of tags.
These tags typically contain per-packet cross-layer information or flow
identifiers (i.e., things that you wouldn&#8217;t find in the bits on the wire).</li>
</ul>
<div class="figure" id="id1">
<img alt="_images/packet.png" src="_images/packet.png" />
<p class="caption">Implementation overview of Packet class.</p>
</div>
<p>Figure <a class="reference internal" href="#id1"><em>Implementation overview of Packet class.</em></a> is a high-level overview of the Packet implementation;
more detail on the byte Buffer implementation is provided later in Figure
<a class="reference internal" href="#buffer"><em>Implementation overview of a packet&#8217;s byte Buffer.</em></a>. In <em>ns-3</em>, the Packet byte buffer is analogous to a Linux skbuff
or BSD mbuf; it is a serialized representation of the actual data in the packet.
The tag lists are containers for extra items useful for simulation convenience;
if a Packet is converted to an emulated packet and put over an actual network,
the tags are stripped off and the byte buffer is copied directly into a real
packet.</p>
<p>Packets are reference counted objects. They are handled with smart pointer (Ptr)
objects like many of the objects in the <em>ns-3</em> system.  One small difference you
will see is that class Packet does not inherit from class Object or class
RefCountBase, and implements the Ref() and Unref() methods directly. This was
designed to avoid the overhead of a vtable in class Packet.</p>
<p>The Packet class is designed to be copied cheaply; the overall design
is based on Copy on Write (COW).  When there are multiple references
to a packet object, and there is an operation on one of them, only
so-called &#8220;dirty&#8221; operations will trigger a deep copy of the packet:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ns3::Packet::AddHeader()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ns3::Packet::AddTrailer()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">both</span> <span class="pre">versions</span> <span class="pre">of</span> <span class="pre">ns3::Packet::AddAtEnd()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Packet::RemovePacketTag()</span></tt></li>
</ul>
<p>The fundamental classes for adding to and removing from the byte buffer are
<tt class="docutils literal"><span class="pre">class</span> <span class="pre">Header</span></tt> and <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Trailer</span></tt>. Headers are more common but the below
discussion also largely applies to protocols using trailers. Every protocol
header that needs to be inserted and removed from a Packet instance should
derive from the abstract Header base class and implement the private pure
virtual methods listed below:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ns3::Header::SerializeTo()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ns3::Header::DeserializeFrom()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ns3::Header::GetSerializedSize()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ns3::Header::PrintTo()</span></tt></li>
</ul>
<p>Basically, the first three functions are used to serialize and deserialize
protocol control information to/from a Buffer. For example, one may define
<tt class="docutils literal"><span class="pre">class</span> <span class="pre">TCPHeader</span> <span class="pre">:</span> <span class="pre">public</span> <span class="pre">Header</span></tt>. The TCPHeader object will typically
consist of some private data (like a sequence number) and public interface
access functions (such as checking the bounds of an input). But the underlying
representation of the TCPHeader in a Packet Buffer is 20 serialized bytes (plus
TCP options). The TCPHeader::SerializeTo() function would therefore be designed
to write these 20 bytes properly into the packet, in network byte order. The
last function is used to define how the Header object prints itself onto an
output stream.</p>
<p>Similarly, user-defined Tags can be appended to the packet. Unlike Headers,
Tags are not serialized into a contiguous buffer but are stored in lists. Tags
can be flexibly defined to be any type, but there can only be one instance of
any particular object type in the Tags buffer at any time.</p>
</div>
<div class="section" id="using-the-packet-interface">
<h2>Using the packet interface<a class="headerlink" href="#using-the-packet-interface" title="Permalink to this headline">¶</a></h2>
<p>This section describes how to create and use the <tt class="docutils literal"><span class="pre">ns3::Packet</span></tt> object.</p>
<div class="section" id="creating-a-new-packet">
<h3>Creating a new packet<a class="headerlink" href="#creating-a-new-packet" title="Permalink to this headline">¶</a></h3>
<p>The following command will create a new packet with a new unique Id.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">pkt</span> <span class="o">=</span> <span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="p">();</span>
</pre></div>
</div>
<p>What is the Uid (unique Id)?  It is an internal id that the system uses to
identify packets.  It can be fetched via the following method::</p>
<div class="highlight-python"><pre>uint32_t uid = pkt-&gt;GetUid ();</pre>
</div>
<p>But please note the following. This uid is an internal uid and cannot be counted
on to provide an accurate counter of how many &#8220;simulated packets&#8221; of a
particular protocol are in the system. It is not trivial to make this uid into
such a counter, because of questions such as what should the uid be when the
packet is sent over broadcast media, or when fragmentation occurs. If a user
wants to trace actual packet counts, he or she should look at e.g. the IP ID
field or transport sequence numbers, or other packet or frame counters at other
protocol layers.</p>
<p>We mentioned above that it is possible to create packets with zero-filled
payloads that do not actually require a memory allocation (i.e., the packet may
behave, when delays such as serialization or transmission delays are computed,
to have a certain number of payload bytes, but the bytes will only be allocated
on-demand when needed).  The command to do this is, when the packet is
created::</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">pkt</span> <span class="o">=</span> <span class="n">Create</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
<p>where N is a positive integer.</p>
<p>The packet now has a size of N bytes, which can be verified by the GetSize()
method::</p>
<div class="highlight-python"><pre>/**
 * \returns the size in bytes of the packet (including the zero-filled
 *          initial payload)
 */
uint32_t GetSize (void) const;</pre>
</div>
<p>You can also initialize a packet with a character buffer. The input
data is copied and the input buffer is untouched. The constructor
applied is::</p>
<div class="highlight-python"><pre>Packet (uint8_t const *buffer, uint32_t size);</pre>
</div>
<p>Here is an example::</p>
<div class="highlight-python"><pre>Ptr&lt;Packet&gt; pkt1 = Create&lt;Packet&gt; (reinterpret_cast&lt;const uint8_t*&gt; ("hello"), 5);</pre>
</div>
<p>Packets are freed when there are no more references to them, as with all <em>ns-3</em>
objects referenced by the Ptr class.</p>
</div>
<div class="section" id="adding-and-removing-buffer-data">
<h3>Adding and removing Buffer data<a class="headerlink" href="#adding-and-removing-buffer-data" title="Permalink to this headline">¶</a></h3>
<p>After the initial packet creation (which may possibly create some fake initial
bytes of payload), all subsequent buffer data is added by adding objects of
class Header or class Trailer. Note that, even if you are in the application
layer, handling packets, and want to write application data, you write it as an
ns3::Header or ns3::Trailer. If you add a Header, it is prepended to the
packet, and if you add a Trailer, it is added to the end of the packet. If you
have no data in the packet, then it makes no difference whether you add a Header
or Trailer. Since the APIs and classes for header and trailer are pretty much
identical, we&#8217;ll just look at class Header here.</p>
<p>The first step is to create a new header class. All new Header classes
must inherit from class Header, and implement the following methods:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Serialize</span> <span class="pre">()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Deserialize</span> <span class="pre">()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">GetSerializedSize</span> <span class="pre">()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Print</span> <span class="pre">()</span></tt></li>
</ul>
<p>To see a simple example of how these are done, look at the UdpHeader class
headers src/internet/model/udp-header.cc. There are many other examples within
the source code.</p>
<p>Once you have a header (or you have a preexisting header), the following
Packet API can be used to add or remove such headers.:</p>
<div class="highlight-python"><pre>/**
 * Add header to this packet. This method invokes the
 * Header::GetSerializedSize and Header::Serialize
 * methods to reserve space in the buffer and request the
 * header to serialize itself in the packet buffer.
 *
 * \param header a reference to the header to add to this packet.
 */
void AddHeader (const Header &amp; header);
/**
 * Deserialize and remove the header from the internal buffer.
 * This method invokes Header::Deserialize.
 *
 * \param header a reference to the header to remove from the internal buffer.
 * \returns the number of bytes removed from the packet.
 */
uint32_t RemoveHeader (Header &amp;header);
/**
 * Deserialize but does _not_ remove the header from the internal buffer.
 * This method invokes Header::Deserialize.
 *
 * \param header a reference to the header to read from the internal buffer.
 * \returns the number of bytes read from the packet.
 */
uint32_t PeekHeader (Header &amp;header) const;</pre>
</div>
<p>For instance, here are the typical operations to add and remove a UDP header.:</p>
<div class="highlight-python"><pre>// add header
Ptr&lt;Packet&gt; packet = Create&lt;Packet&gt; ();
UdpHeader udpHeader;
// Fill out udpHeader fields appropriately
packet-&gt;AddHeader (udpHeader);
...
// remove header
UdpHeader udpHeader;
packet-&gt;RemoveHeader (udpHeader);
// Read udpHeader fields as needed</pre>
</div>
</div>
<div class="section" id="adding-and-removing-tags">
<h3>Adding and removing Tags<a class="headerlink" href="#adding-and-removing-tags" title="Permalink to this headline">¶</a></h3>
<p>There is a single base class of Tag that all packet tags must derive from. They
are used in two different tag lists in the packet; the lists have different
semantics and different expected use cases.</p>
<p>As the names imply, ByteTags follow bytes and PacketTags follow packets. What
this means is that when operations are done on packets, such as fragmentation,
concatenation, and appending or removing headers, the byte tags keep track of
which packet bytes they cover. For instance, if a user creates a TCP segment,
and applies a ByteTag to the segment, each byte of the TCP segment will be
tagged. However, if the next layer down inserts an IPv4 header, this ByteTag
will not cover those bytes.  The converse is true for the PacketTag; it covers a
packet despite the operations on it.</p>
<p>PacketTags are limited in size to 20 bytes. This is a modifiable compile-time
constant in <tt class="docutils literal"><span class="pre">src/network/model/packet-tag-list.h</span></tt>. ByteTags have no such restriction.</p>
<p>Each tag type must subclass <tt class="docutils literal"><span class="pre">ns3::Tag</span></tt>, and only one instance of
each Tag type may be in each tag list. Here are a few differences in the
behavior of packet tags and byte tags.</p>
<ul class="simple">
<li><strong>Fragmentation:</strong>  As mentioned above, when a packet is fragmented, each
packet fragment (which is a new packet) will get a copy of all packet tags,
and byte tags will follow the new packet boundaries (i.e. if the fragmented
packets fragment across a buffer region covered by the byte tag, both packet
fragments will still have the appropriate buffer regions byte tagged).</li>
<li><strong>Concatenation:</strong> When packets are combined, two different buffer regions
will become one. For byte tags, the byte tags simply follow the respective
buffer regions. For packet tags, only the tags on the first packet survive
the merge.</li>
<li><strong>Finding and Printing:</strong> Both classes allow you to iterate over all of the
tags and print them.</li>
<li><strong>Removal:</strong> Users can add and remove the same packet tag multiple times on a
single packet (AddPacketTag () and RemovePacketTag ()). The packet However,
once a byte tag is added, it can only be removed by stripping all byte tags
from the packet. Removing one of possibly multiple byte tags is not supported
by the current API.</li>
</ul>
<p>As of <em>ns-3.5</em> and later, Tags are not serialized and deserialized to a buffer when
<tt class="docutils literal"><span class="pre">Packet::Serialize</span> <span class="pre">()</span></tt> and <tt class="docutils literal"><span class="pre">Packet::Deserialize</span> <span class="pre">()</span></tt> are called; this is an
open bug.</p>
<p>If a user wants to take an existing packet object and reuse it as a new packet,
he or she should remove all byte tags and packet tags before doing so. An
example is the UdpEchoServer class, which takes the received packet and &#8220;turns
it around&#8221; to send back to the echo client.</p>
<p>The Packet API for byte tags is given below.:</p>
<div class="highlight-python"><pre>/**
 * \param tag the new tag to add to this packet
 *
 * Tag each byte included in this packet with the
 * new tag.
 *
 * Note that adding a tag is a const operation which is pretty
 * un-intuitive. The rationale is that the content and behavior of
 * a packet is _not_ changed when a tag is added to a packet: any
 * code which was not aware of the new tag is going to work just
 * the same if the new tag is added. The real reason why adding a
 * tag was made a const operation is to allow a trace sink which gets
 * a packet to tag the packet, even if the packet is const (and most
 * trace sources should use const packets because it would be
 * totally evil to allow a trace sink to modify the content of a
 * packet).
 */
void AddByteTag (const Tag &amp;tag) const;
/**
 * \returns an iterator over the set of byte tags included in this packet.
 */
ByteTagIterator GetByteTagIterator (void) const;
/**
 * \param tag the tag to search in this packet
 * \returns true if the requested tag type was found, false otherwise.
 *
 * If the requested tag type is found, it is copied in the user's
 * provided tag instance.
 */
bool FindFirstMatchingByteTag (Tag &amp;tag) const;

/**
 * Remove all the tags stored in this packet.
 */
void RemoveAllByteTags (void);

/**
 * \param os output stream in which the data should be printed.
 *
 * Iterate over the tags present in this packet, and
 * invoke the Print method of each tag stored in the packet.
 */
void PrintByteTags (std::ostream &amp;os) const;</pre>
</div>
<p>The Packet API for packet tags is given below.:</p>
<div class="highlight-python"><pre>/**
 * \param tag the tag to store in this packet
 *
 * Add a tag to this packet. This method calls the
 * Tag::GetSerializedSize and, then, Tag::Serialize.
 *
 * Note that this method is const, that is, it does not
 * modify the state of this packet, which is fairly
 * un-intuitive.
 */
void AddPacketTag (const Tag &amp;tag) const;
/**
 * \param tag the tag to remove from this packet
 * \returns true if the requested tag is found, false
 *          otherwise.
 *
 * Remove a tag from this packet. This method calls
 * Tag::Deserialize if the tag is found.
 */
bool RemovePacketTag (Tag &amp;tag);
/**
 * \param tag the tag to search in this packet
 * \returns true if the requested tag is found, false
 *          otherwise.
 *
 * Search a matching tag and call Tag::Deserialize if it is found.
 */
bool PeekPacketTag (Tag &amp;tag) const;
/**
 * Remove all packet tags.
 */
void RemoveAllPacketTags (void);

/**
 * \param os the stream in which we want to print data.
 *
 * Print the list of 'packet' tags.
 *
 * \sa Packet::AddPacketTag, Packet::RemovePacketTag, Packet::PeekPacketTag,
 *  Packet::RemoveAllPacketTags
 */
void PrintPacketTags (std::ostream &amp;os) const;

/**
 * \returns an object which can be used to iterate over the list of
 *  packet tags.
 */
PacketTagIterator GetPacketTagIterator (void) const;</pre>
</div>
<p>Here is a simple example illustrating the use of tags from the
code in <tt class="docutils literal"><span class="pre">src/internet/model/udp-socket-impl.cc</span></tt>::</p>
<div class="highlight-python"><pre>Ptr&lt;Packet&gt; p;  // pointer to a pre-existing packet
SocketIpTtlTag tag
tag.SetTtl (m_ipMulticastTtl); // Convey the TTL from UDP layer to IP layer
p-&gt;AddPacketTag (tag);</pre>
</div>
<p>This tag is read at the IP layer, then stripped (<tt class="docutils literal"><span class="pre">src/internet/model/ipv4-l3-protocol.cc</span></tt>)::</p>
<div class="highlight-python"><pre>uint8_t ttl = m_defaultTtl;
SocketIpTtlTag tag;
bool found = packet-&gt;RemovePacketTag (tag);
if (found)
  {
    ttl = tag.GetTtl ();
  }</pre>
</div>
</div>
<div class="section" id="fragmentation-and-concatenation">
<h3>Fragmentation and concatenation<a class="headerlink" href="#fragmentation-and-concatenation" title="Permalink to this headline">¶</a></h3>
<p>Packets may be fragmented or merged together.  For example, to fragment a packet
<tt class="docutils literal"><span class="pre">p</span></tt> of 90 bytes into two packets, one containing the first 10 bytes and the
other containing the remaining 80, one may call the following code::</p>
<div class="highlight-python"><pre>Ptr&lt;Packet&gt; frag0 = p-&gt;CreateFragment (0, 10);
Ptr&lt;Packet&gt; frag1 = p-&gt;CreateFragment (10, 90);</pre>
</div>
<p>As discussed above, the packet tags from <tt class="docutils literal"><span class="pre">p</span></tt> will follow to both packet
fragments, and the byte tags will follow the byte ranges as needed.</p>
<p>Now, to put them back together::</p>
<div class="highlight-python"><pre>frag0-&gt;AddAtEnd (frag1);</pre>
</div>
<p>Now frag0 should be equivalent to the original packet <tt class="docutils literal"><span class="pre">p</span></tt>.  If, however, there
were operations on the fragments before being reassembled (such as tag
operations or header operations), the new packet will not be the same.</p>
</div>
<div class="section" id="enabling-metadata">
<h3>Enabling metadata<a class="headerlink" href="#enabling-metadata" title="Permalink to this headline">¶</a></h3>
<p>We mentioned above that packets, being on-the-wire representations of byte
buffers, present a problem to print out in a structured way unless the printing
function has access to the context of the header.  For instance, consider a
tcpdump-like printer that wants to pretty-print the contents of a packet.</p>
<p>To enable this usage, packets may have metadata enabled (disabled by default for
performance reasons). This class is used by the Packet class to record every
operation performed on the packet&#8217;s buffer, and provides an implementation of
<tt class="docutils literal"><span class="pre">Packet::Print</span> <span class="pre">()</span></tt> method that uses the metadata to analyze the content of the
packet&#8217;s buffer.</p>
<p>The metadata is also used to perform extensive sanity checks at runtime when
performing operations on a Packet. For example, this metadata is used to verify
that when you remove a header from a packet, this same header was actually
present at the front of the packet. These errors will be detected and will abort
the program.</p>
<p>To enable this operation, users will typically insert one or both of these
statements at the beginning of their programs::</p>
<div class="highlight-python"><pre>Packet::EnablePrinting ();
Packet::EnableChecking ();</pre>
</div>
</div>
</div>
<div class="section" id="sample-programs">
<h2>Sample programs<a class="headerlink" href="#sample-programs" title="Permalink to this headline">¶</a></h2>
<p>See <tt class="docutils literal"><span class="pre">src/network/examples/main-packet-header.cc</span></tt> and <tt class="docutils literal"><span class="pre">src/network/examples/main-packet-tag.cc</span></tt>.</p>
</div>
<div class="section" id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="private-member-variables">
<h3>Private member variables<a class="headerlink" href="#private-member-variables" title="Permalink to this headline">¶</a></h3>
<p>A Packet object&#8217;s interface provides access to some private data::</p>
<div class="highlight-python"><pre>Buffer m_buffer;
ByteTagList m_byteTagList;
PacketTagList m_packetTagList;
PacketMetadata m_metadata;
mutable uint32_t m_refCount;
static uint32_t m_globalUid;</pre>
</div>
<p>Each Packet has a Buffer and two Tags lists, a PacketMetadata object, and a ref
count. A static member variable keeps track of the UIDs allocated. The actual
uid of the packet is stored in the PacketMetadata.</p>
<p>Note:
that real network packets do not have a UID; the UID is therefore an instance of
data that normally would be stored as a Tag in the packet. However, it was felt
that a UID is a special case that is so often used in simulations that it would
be more convenient to store it in a member variable.</p>
</div>
<div class="section" id="buffer-implementation">
<h3>Buffer implementation<a class="headerlink" href="#buffer-implementation" title="Permalink to this headline">¶</a></h3>
<p>Class Buffer represents a buffer of bytes. Its size is automatically adjusted to
hold any data prepended or appended by the user. Its implementation is optimized
to ensure that the number of buffer resizes is minimized, by creating new
Buffers of the maximum size ever used.  The correct maximum size is learned at
runtime during use by recording the maximum size of each packet.</p>
<p>Authors of new Header or Trailer classes need to know the public API of the
Buffer class.  (add summary here)</p>
<p>The byte buffer is implemented as follows:</p>
<div class="highlight-python"><pre>struct BufferData {
    uint32_t m_count;
    uint32_t m_size;
    uint32_t m_initialStart;
    uint32_t m_dirtyStart;
    uint32_t m_dirtySize;
    uint8_t m_data[1];
};
struct BufferData *m_data;
uint32_t m_zeroAreaSize;
uint32_t m_start;
uint32_t m_size;</pre>
</div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">BufferData::m_count</span></tt>: reference count for BufferData structure</li>
<li><tt class="docutils literal"><span class="pre">BufferData::m_size</span></tt>: size of data buffer stored in BufferData structure</li>
<li><tt class="docutils literal"><span class="pre">BufferData::m_initialStart</span></tt>: offset from start of data buffer where data
was first inserted</li>
<li><tt class="docutils literal"><span class="pre">BufferData::m_dirtyStart</span></tt>: offset from start of buffer where every Buffer
which holds a reference to this BufferData instance have written data so far</li>
<li><tt class="docutils literal"><span class="pre">BufferData::m_dirtySize</span></tt>: size of area where data has been written so far</li>
<li><tt class="docutils literal"><span class="pre">BufferData::m_data</span></tt>: pointer to data buffer</li>
<li><tt class="docutils literal"><span class="pre">Buffer::m_zeroAreaSize</span></tt>: size of zero area which extends before
<tt class="docutils literal"><span class="pre">m_initialStart</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Buffer::m_start</span></tt>: offset from start of buffer to area used by this buffer</li>
<li><tt class="docutils literal"><span class="pre">Buffer::m_size</span></tt>: size of area used by this Buffer in its BufferData
structure</li>
</ul>
<div class="figure" id="buffer">
<img alt="_images/buffer.png" src="_images/buffer.png" />
<p class="caption">Implementation overview of a packet&#8217;s byte Buffer.</p>
</div>
<p>This data structure is summarized in Figure <a class="reference internal" href="#buffer"><em>Implementation overview of a packet&#8217;s byte Buffer.</em></a>. Each Buffer holds a
pointer to an instance of a BufferData. Most Buffers should be able to share the
same underlying BufferData and thus simply increase the BufferData&#8217;s reference
count. If they have to change the content of a BufferData inside the Dirty Area,
and if the reference count is not one, they first create a copy of the
BufferData and then complete their state-changing operation.</p>
</div>
<div class="section" id="tags-implementation">
<h3>Tags implementation<a class="headerlink" href="#tags-implementation" title="Permalink to this headline">¶</a></h3>
<p>(XXX revise me)</p>
<p>Tags are implemented by a single pointer which points to the start of a
linked list ofTagData data structures. Each TagData structure points
to the next TagData in the list (its next pointer contains zero to
indicate the end of the linked list). Each TagData contains an integer
unique id which identifies the type of the tag stored in the TagData.:</p>
<div class="highlight-python"><pre>struct TagData {
    struct TagData *m_next;
    uint32_t m_id;
    uint32_t m_count;
    uint8_t m_data[Tags::SIZE];
};
class Tags {
    struct TagData *m_next;
};</pre>
</div>
<p>Adding a tag is a matter of inserting a new TagData at the head of the linked
list. Looking at a tag requires you to find the relevant TagData in the linked
list and copy its data into the user data structure. Removing a tag and updating
the content of a tag requires a deep copy of the linked list before performing
this operation.  On the other hand, copying a Packet and its tags is a matter of
copying the TagData head pointer and incrementing its reference count.</p>
<p>Tags are found by the unique mapping between the Tag type and
its underlying id. This is why at most one instance of any Tag
can be stored in a packet. The mapping between Tag type and
underlying id is performed by a registration as follows::</p>
<div class="highlight-python"><pre>/* A sample Tag implementation
 */
struct MyTag {
    uint16_t m_streamId;
};</pre>
</div>
</div>
<div class="section" id="memory-management">
<h3>Memory management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h3>
<p><em>Describe dataless vs. data-full packets.</em></p>
</div>
<div class="section" id="copy-on-write-semantics">
<h3>Copy-on-write semantics<a class="headerlink" href="#copy-on-write-semantics" title="Permalink to this headline">¶</a></h3>
<p>The current implementation of the byte buffers and tag list is based on COW
(Copy On Write). An introduction to COW can be found in Scott Meyer&#8217;s &#8220;More
Effective C++&#8221;, items 17 and 29). This design feature and aspects of the public
interface borrows from the packet design of the Georgia Tech Network Simulator.
This implementation of COW uses a customized reference counting smart pointer
class.</p>
<p>What COW means is that copying packets without modifying them is very cheap (in
terms of CPU and memory usage) and modifying them can be also very cheap. What
is key for proper COW implementations is being able to detect when a given
modification of the state of a packet triggers a full copy of the data prior to
the modification: COW systems need to detect when an operation is &#8220;dirty&#8221; and
must therefore invoke a true copy.</p>
<p>Dirty operations:</p>
<ul class="simple">
<li>ns3::Packet::AddHeader</li>
<li>ns3::Packet::AddTrailer</li>
<li>both versions of ns3::Packet::AddAtEnd</li>
<li>ns3::Packet::RemovePacketTag</li>
</ul>
<p>Non-dirty operations:</p>
<ul class="simple">
<li>ns3::Packet::AddPacketTag</li>
<li>ns3::Packet::PeekPacketTag</li>
<li>ns3::Packet::RemoveAllPacketTags</li>
<li>ns3::Packet::AddByteTag</li>
<li>ns3::Packet::FindFirstMatchingByteTag</li>
<li>ns3::Packet::RemoveAllByteTags</li>
<li>ns3::Packet::RemoveHeader</li>
<li>ns3::Packet::RemoveTrailer</li>
<li>ns3::Packet::CreateFragment</li>
<li>ns3::Packet::RemoveAtStart</li>
<li>ns3::Packet::RemoveAtEnd</li>
<li>ns3::Packet::CopyData</li>
</ul>
<p>Dirty operations will always be slower than non-dirty operations, sometimes by
several orders of magnitude. However, even the dirty operations have been
optimized for common use-cases which means that most of the time, these
operations will not trigger data copies and will thus be still very fast.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Packets</a><ul>
<li><a class="reference internal" href="#packet-design-overview">Packet design overview</a></li>
<li><a class="reference internal" href="#using-the-packet-interface">Using the packet interface</a><ul>
<li><a class="reference internal" href="#creating-a-new-packet">Creating a new packet</a></li>
<li><a class="reference internal" href="#adding-and-removing-buffer-data">Adding and removing Buffer data</a></li>
<li><a class="reference internal" href="#adding-and-removing-tags">Adding and removing Tags</a></li>
<li><a class="reference internal" href="#fragmentation-and-concatenation">Fragmentation and concatenation</a></li>
<li><a class="reference internal" href="#enabling-metadata">Enabling metadata</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sample-programs">Sample programs</a></li>
<li><a class="reference internal" href="#implementation-details">Implementation details</a><ul>
<li><a class="reference internal" href="#private-member-variables">Private member variables</a></li>
<li><a class="reference internal" href="#buffer-implementation">Buffer implementation</a></li>
<li><a class="reference internal" href="#tags-implementation">Tags implementation</a></li>
<li><a class="reference internal" href="#memory-management">Memory management</a></li>
<li><a class="reference internal" href="#copy-on-write-semantics">Copy-on-write semantics</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="network.html"
                        title="previous chapter">Network Module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="network-overview.html"
                        title="next chapter">Node and NetDevices Overview</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/packets.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="network-overview.html" title="Node and NetDevices Overview"
             >next</a> |</li>
        <li class="right" >
          <a href="network.html" title="Network Module"
             >previous</a> |</li>
    <li class="navelem"><a href="">ns-3</a><span class="navelem">&nbsp;</span></li>
    
        <li><a href="index.html">Models</a><span class="navelem">&nbsp;</span></li>

          <li><a href="network.html" >Network Module</a><span class="navelem">&nbsp;</span></li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, ns-3 project.
      Last updated on Oct 17, 2012 10:56.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>